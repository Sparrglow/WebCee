#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "core/diagnostic.h"
#include "core/lexer.h"
#include "core/parser.h"
#include "core/ast.h"
#include "core/memory_pool.h"
#include "core/ir.h"
#include "core/codegen.h"

// Simple file reader with UTF-8 BOM handling
static char* read_file(const char* path) {
    FILE* f = fopen(path, "rb");
    if (!f) return NULL;
    
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, 0, SEEK_SET);
    
    char* content = (char*)malloc(size + 1);
    if (content) {
        fread(content, 1, size, f);
        content[size] = '\0';
        
        // Skip UTF-8 BOM if present (EF BB BF)
        if (size >= 3 && (unsigned char)content[0] == 0xEF && 
            (unsigned char)content[1] == 0xBB && (unsigned char)content[2] == 0xBF) {
            // Move content to skip BOM
            memmove(content, content + 3, size - 3 + 1);
        }
    }
    fclose(f);
    return content;
}

int main(int argc, char** argv) {
    if (argc < 2) {
        printf("Usage: wce <input.wce> [output.c] [--dump-ir]\n");
        return 1;
    }
    
    const char* input_path = argv[1];
    const char* output_path = (argc >= 3) ? argv[2] : "webcee_generated.c";
    
    char* source = read_file(input_path);
    if (!source) {
        printf("Error: Could not read file '%s'\n", input_path);
        return 1;
    }
    
    DiagnosticBag* bag = diagnostic_bag_create();
    Lexer* lexer = lexer_create(source, input_path, bag);
    MemoryPool* pool = memory_pool_create(1024 * 1024); // 1MB pool
    Parser* parser = parser_create(lexer, bag, pool);
    
    WceAstNode* ast = parser_parse(parser);
    
    if (diagnostic_has_errors(bag)) {
        diagnostic_print_all(bag);
        parser_destroy(parser);
        lexer_destroy(lexer);
        diagnostic_bag_destroy(bag);
        memory_pool_destroy(pool);
        free(source);
        return 1;
    }

    // AST to IR
    WceIrContext* ir_ctx = ir_build_from_ast(pool, ast, bag);
    if (!ir_ctx) {
        printf("Error: Failed to build IR from AST\n");
        parser_destroy(parser);
        lexer_destroy(lexer);
        diagnostic_bag_destroy(bag);
        memory_pool_destroy(pool);
        free(source);
        return 1;
    }
    
    // Perform IR analysis
    ir_analyze(ir_ctx, bag);
    
    // Check for errors after IR construction and analysis
    if (diagnostic_has_errors(bag)) {
        diagnostic_print_all(bag);
        // Cleanup and exit
        parser_destroy(parser);
        lexer_destroy(lexer);
        diagnostic_bag_destroy(bag);
        memory_pool_destroy(pool);
        free(source);
        return 1;
    }
    
    // Check for --dump-ir flag
    int dump_ir = 0;
    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--dump-ir") == 0) {
            dump_ir = 1;
            break;
        }
    }
    
    if (dump_ir) {
        ir_dump(ir_ctx, stdout);
        // Cleanup and exit
        parser_destroy(parser);
        lexer_destroy(lexer);
        diagnostic_bag_destroy(bag);
        memory_pool_destroy(pool);
        free(source);
        return 0;
    }
    
    FILE* out = fopen(output_path, "w");
    if (!out) {
        printf("Error: Could not open output file '%s'\n", output_path);
        parser_destroy(parser);
        lexer_destroy(lexer);
        diagnostic_bag_destroy(bag);
        memory_pool_destroy(pool);
        free(source);
        return 1;
    }
    
    fprintf(out, "// Generated by WebCee Compiler (IR pipeline)\n");
    fprintf(out, "#include \"webcee.h\"\n\n");
    fprintf(out, "void wce_ui_main() {\n");
    codegen_generate(ir_ctx->root, out);
    fprintf(out, "}\n");
    
    fclose(out);
    printf("Successfully compiled '%s' to '%s' via IR pipeline\n", input_path, output_path);
    
    // Cleanup
    parser_destroy(parser);
    lexer_destroy(lexer);
    diagnostic_bag_destroy(bag);
    memory_pool_destroy(pool);
    free(source);
    
    return 0;
}
